{"version":3,"file":"recorder.8d60166141d2ee725d5d.js","mappings":"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","sources":["webpack://spine/webpack/runtime/chunk loaded","webpack://spine/./src/stym/canvas_recorder.ts","webpack://spine/./src/recorder.ts","webpack://spine/webpack/bootstrap","webpack://spine/webpack/runtime/define property getters","webpack://spine/webpack/runtime/hasOwnProperty shorthand","webpack://spine/webpack/runtime/jsonp chunk loading","webpack://spine/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import { AnimationStateListener, TrackEntry } from \"../core/AnimationState\";\r\nimport { Actor } from \"../player/Actor\";\r\nimport { ManagedWebGLRenderingContext } from \"../webgl/WebGL\";\r\nimport { Runtime } from \"./runtime\";\r\nimport { Event } from \"../core/Event\";\r\nimport \"./stym.css\";\r\n\r\nexport class CanvasRecorder {\r\n    private dom: HTMLElement;\r\n    private parent: HTMLElement | null;\r\n    private runtime: Runtime;\r\n\r\n    constructor(parent: HTMLElement | string, runtime: Runtime) {\r\n        if (typeof parent === \"string\") {\r\n            this.parent = document.getElementById(parent);\r\n        } else {\r\n            this.parent = parent;\r\n        }\r\n        this.parent?.appendChild(this.setupDom());\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    private getElementById(dom: HTMLElement, id: string): HTMLElement {\r\n        return this.findWithId(this.dom, id)[0];\r\n    }\r\n\r\n    private findWithId(dom: HTMLElement, id: string): HTMLElement[] {\r\n        let found = new Array<HTMLElement>()\r\n        let findRecursive = (dom: HTMLElement, id: string, found: HTMLElement[]) => {\r\n            for (var i = 0; i < dom.children.length; i++) {\r\n                let child = dom.children[i] as HTMLElement;\r\n                if (child.id === id) found.push(child);\r\n                findRecursive(child, id, found);\r\n            }\r\n        };\r\n        findRecursive(dom, id, found);\r\n        return found;\r\n    }\r\n\r\n    private findWithClass(dom: HTMLElement, className: string): HTMLElement[] {\r\n        let found = new Array<HTMLElement>()\r\n        let findRecursive = (dom: HTMLElement, className: string, found: HTMLElement[]) => {\r\n            for (var i = 0; i < dom.children.length; i++) {\r\n                let child = dom.children[i] as HTMLElement;\r\n                if (child.classList.contains(className)) found.push(child);\r\n                findRecursive(child, className, found);\r\n            }\r\n        };\r\n        findRecursive(dom, className, found);\r\n        return found;\r\n    }\r\n\r\n    public createElement(html: string): HTMLElement {\r\n        let dom = document.createElement(\"div\");\r\n        dom.innerHTML = html;\r\n        return dom.children[0] as HTMLElement;\r\n    }\r\n\r\n    public setupDom(): HTMLElement {\r\n        let dom = this.dom = this.createElement(/*html*/`\r\n\t\t\t\t<div class=\"save_canvas_container\">\r\n                    <label>File Format</label>\r\n                    <select id=\"file_format_select_id\">\r\n                    </select>\r\n                    <br />\r\n\r\n                    <label>Output Filename</label>\r\n                    <input id=\"output_filename\" type=\"text\" placeholder=\"video filename\" defaultValue=\"video.mp4\"  size=50 />\r\n                    <br />\r\n\r\n                    <div>\r\n                        <label>Record Mode</label>\r\n                        <select id=\"record_mode_select_id\">\r\n                            <option value=\"manual\" selected>Manual</option>\r\n                            <option value=\"actor\">Choose Actor</option>\r\n                            <option value=\"duration\">Duration</option>\r\n                        </select>\r\n\r\n                        <div class=\"record_mode_manual\">\r\n                            <button class=\"record-button\">Record</button>\r\n                        </div>\r\n\r\n                        <div class=\"record_mode_actor hidden\">\r\n                            <label>Choose Actor</label>\r\n                            <select id=\"actor_select_id\">\r\n                            </select>\r\n                            <button class=\"save-button-actor\">Save</button>\r\n                        </div>\r\n\r\n                        <div class=\"record_mode_duration hidden\">\r\n                            <label>Record Duration (seconds)</label>\r\n                            <input id=\"record_duration_id\" type=\"number\" placeholder=\"start time\" defaultValue=\"2\" value=\"2\" step=\"0.001\"/>\r\n                            <button class=\"save-button-duration\">Save</button>\r\n                        </div>\r\n\r\n                        <br />\r\n                        <div>Status: <span id=\"record_status\"></span></div>\r\n                    </div>\r\n                    \r\n                    <div class=\"output_container hidden\">\r\n                        <p>Output files</p>\r\n                    </div>\r\n                </div>\r\n\t\t\t`)\r\n        document.body.appendChild(this.dom);\r\n        this.setupData(this.dom);\r\n        this.addListeners(this.dom);\r\n        return dom;\r\n    }\r\n\r\n    private setupData(dom: HTMLElement) {\r\n        let selectElem = this.getElementById(dom, \"file_format_select_id\");\r\n        const browserSupportedMimeTypes = getAllSupportedMimeTypes(\"video\");\r\n        browserSupportedMimeTypes.forEach(mimeType => {\r\n            selectElem.appendChild(\r\n                this.createElement(`<option value=\"${mimeType}\">${mimeType}</option>`)\r\n            )\r\n        });\r\n\r\n        // set default download file name\r\n        (this.getElementById(dom, \"output_filename\") as HTMLInputElement).value = `vid_${crypto.randomUUID()}.mp4`;\r\n    }\r\n\r\n    private setStatus(txt: string, clear ?:boolean) {\r\n        this.getElementById(this.dom, \"record_status\").innerText = txt;\r\n        if (clear) {\r\n            setTimeout(() => {\r\n                this.getElementById(this.dom, \"record_status\").innerText = \"\";\r\n            }, 5000);\r\n        }\r\n    }\r\n\r\n    private getOutputFilename(): string {\r\n        return (this.getElementById(this.dom, \"output_filename\") as HTMLInputElement).value;\r\n    }\r\n\r\n    private recordManualStart() {\r\n        let saveContext: SaveContextManual = null;\r\n        return (event: any) => {\r\n            console.log(\"Record button\");\r\n            let dom = this.dom;\r\n            if (saveContext == null) {\r\n                console.log(\"start manual recording\");\r\n                event.target.innerText = \"Stop\";\r\n                // Start the recording\r\n                let outputFilename = this.getOutputFilename();\r\n                let selectedMimeType = (this.getElementById(dom, \"file_format_select_id\") as HTMLInputElement).value;\r\n                saveContext = new SaveContextManual(\r\n                    outputFilename,\r\n                    selectedMimeType,\r\n                    this.saveBlob(),\r\n                    this.setStatus.bind(this)\r\n                );\r\n                let removalFn = this.runtime.spinePlayer.registerRenderCallback(\r\n                    saveContext.renderCallback.bind(saveContext)\r\n                );\r\n                saveContext.removalFn = removalFn;\r\n\r\n            } else {\r\n                console.log(\"Stop manual recording\");\r\n                event.target.innerText = \"Record\";\r\n                saveContext.recorder.stop();\r\n                saveContext.removalFn();\r\n                saveContext = null;\r\n            }\r\n        };\r\n    }\r\n\r\n    private addListeners(dom: HTMLElement) {\r\n        this.getElementById(dom, \"record_mode_select_id\").addEventListener(\"change\", ((event: any) => {\r\n            let selection = (event.target as HTMLSelectElement).value;\r\n            let recordModeActor = this.findWithClass(dom, \"record_mode_actor\")[0];\r\n            let recordModeDuration = this.findWithClass(dom, \"record_mode_duration\")[0];\r\n            let recordModeManual = this.findWithClass(dom, \"record_mode_manual\")[0];\r\n\r\n            if (selection === \"actor\") {\r\n                recordModeActor.classList.remove(\"hidden\");\r\n                recordModeDuration.classList.add(\"hidden\");\r\n                recordModeManual.classList.add(\"hidden\");\r\n\r\n                recordModeActor.querySelector(\"select\").innerHTML = \"\";\r\n                this.runtime.spinePlayer.getActorNames().forEach(actorName => {\r\n                    let encodedName = encodeURIComponent(actorName);\r\n                    let opt = this.createElement(`<option value=\"${encodedName}\"></option>`)\r\n                    opt.innerText = `${encodedName}`;\r\n                    recordModeActor.querySelector(\"select\").appendChild(opt);\r\n                })\r\n            } else if (selection === \"duration\") {\r\n                recordModeActor.classList.add(\"hidden\");\r\n                recordModeDuration.classList.remove(\"hidden\");\r\n                recordModeManual.classList.add(\"hidden\");\r\n            } else if (selection === \"manual\") {\r\n                recordModeActor.classList.add(\"hidden\");\r\n                recordModeDuration.classList.add(\"hidden\");\r\n                recordModeManual.classList.remove(\"hidden\");\r\n            }\r\n        }).bind(this))\r\n\r\n        this.findWithClass(dom, \"record-button\")[0].addEventListener(\r\n            \"click\", \r\n            this.recordManualStart(),\r\n        );\r\n        this.findWithClass(dom, \"save-button-actor\")[0].addEventListener(\"click\", (event) => {\r\n            let outputFilename = this.getOutputFilename();\r\n            let selectedMimeType = (this.getElementById(dom, \"file_format_select_id\") as HTMLInputElement).value;\r\n            let encodedSelectedActor = (this.getElementById(dom, \"actor_select_id\") as HTMLSelectElement).value;\r\n            let decodedSelectedActor = decodeURIComponent(encodedSelectedActor);\r\n\r\n            let actor = this.runtime.spinePlayer.getActor(decodedSelectedActor);\r\n            if (!actor || actor === undefined) {\r\n                console.log(\"Actor not found\");\r\n                return;\r\n            }\r\n            const saveContext = new SaveContextActor(\r\n                outputFilename,\r\n                selectedMimeType,\r\n                this.saveBlob(),\r\n                this.setStatus.bind(this)\r\n            );\r\n            saveContext.setup(actor);\r\n            let removalFn = this.runtime.spinePlayer.registerRenderCallback(\r\n                saveContext.renderCallback.bind(saveContext)\r\n            );\r\n            saveContext.removalFn = removalFn;\r\n        });\r\n        this.findWithClass(dom, \"save-button-duration\")[0].addEventListener(\"click\", (event) => {\r\n            let outputFilename = this.getOutputFilename();\r\n            let selectedMimeType = (this.getElementById(dom, \"file_format_select_id\") as HTMLInputElement).value;\r\n            let duration = (this.getElementById(dom, \"record_duration_id\") as HTMLInputElement).valueAsNumber;\r\n\r\n            const saveContext = new SaveContextDuration(\r\n                outputFilename,\r\n                selectedMimeType,\r\n                this.saveBlob(),\r\n                this.setStatus.bind(this)\r\n            );\r\n            saveContext.setup(duration);\r\n            let removalFn = this.runtime.spinePlayer.registerRenderCallback(\r\n                saveContext.renderCallback.bind(saveContext)\r\n            );\r\n            saveContext.removalFn = removalFn;\r\n        });\r\n    }\r\n\r\n    private saveBlob() {\r\n        const a = document.createElement('a');\r\n        let outputContainer = this.findWithClass(this.dom, \"output_container\")[0];\r\n        outputContainer.appendChild(a);\r\n\r\n        return function saveData(blob: Blob, fileName: string) {\r\n            const url = window.URL.createObjectURL(blob);\r\n            a.href = url;\r\n            a.download = fileName;\r\n            a.click();\r\n            setTimeout(() => { \r\n                outputContainer.removeChild(a)\r\n            });\r\n        };\r\n    };\r\n}\r\n\r\n// @ts-ignore\r\nfunction getAllSupportedMimeTypes(...mediaTypes) {\r\n    if (!mediaTypes.length) mediaTypes.push('video', 'audio')\r\n    const CONTAINERS = ['webm', 'ogg', 'mp3', 'mp4', 'x-matroska', '3gpp', '3gpp2', '3gp2', 'quicktime', 'mpeg', 'aac', 'flac', 'x-flac', 'wave', 'wav', 'x-wav', 'x-pn-wav', 'not-supported']\r\n    const CODECS = ['vp9', 'vp9.0', 'vp8', 'vp8.0', 'avc1', 'av1', 'h265', 'h.265', 'h264', 'h.264', 'opus', 'vorbis', 'pcm', 'aac', 'mpeg', 'mp4a', 'rtx', 'red', 'ulpfec', 'g722', 'pcmu', 'pcma', 'cn', 'telephone-event', 'not-supported']\r\n\r\n    return [...new Set(\r\n        CONTAINERS.flatMap(ext =>\r\n            mediaTypes.flatMap(mediaType => [\r\n                `${mediaType}/${ext}`,\r\n            ]),\r\n        ),\r\n    ), ...new Set(\r\n        CONTAINERS.flatMap(ext =>\r\n            CODECS.flatMap(codec =>\r\n                mediaTypes.flatMap(mediaType => [\r\n                    // NOTE: 'codecs:' will always be true (false positive)\r\n                    `${mediaType}/${ext};codecs=${codec}`,\r\n                ]),\r\n            ),\r\n        ),\r\n    ), ...new Set(\r\n        CONTAINERS.flatMap(ext =>\r\n            CODECS.flatMap(codec1 =>\r\n                CODECS.flatMap(codec2 =>\r\n                    mediaTypes.flatMap(mediaType => [\r\n                        `${mediaType}/${ext};codecs=\"${codec1}, ${codec2}\"`,\r\n                    ]),\r\n                ),\r\n            ),\r\n        ),\r\n    )].filter(variation => MediaRecorder.isTypeSupported(variation))\r\n}\r\n\r\nfunction hexToNumber(hex: string): number {\r\n    const trimmed = hex.trim();\r\n    if (trimmed.length === 0) {\r\n        return 0;\r\n    }\r\n    return parseInt(trimmed, 16);\r\n}\r\n\r\nclass SaveContext {\r\n    public removalFn: () => void;\r\n    public saveBlobFn: (blob: Blob, fileName: string) => void = null;\r\n    public setStatusFn: (txt:string, clear ?: boolean) => void = null;\r\n    public outputFilename: string = '';\r\n    public mimeType: string = 'video/mp4;codec=vp9';\r\n    public chunks: Blob[] = [];\r\n    public recorder: MediaRecorder;\r\n    public frameCount: number = 0;\r\n\r\n    constructor(\r\n        outputFilename: string,\r\n        mimeType: string,\r\n        saveBlobFn: (blob: Blob, fileName: string) => void,\r\n        setStatusFn: (txt: string, clear ?: boolean) => void\r\n    ) {\r\n        this.removalFn = null;\r\n        this.saveBlobFn = saveBlobFn;\r\n        this.setStatusFn = setStatusFn;\r\n        this.outputFilename = outputFilename;\r\n        this.mimeType = mimeType;\r\n    }\r\n\r\n    public startRecording(context: ManagedWebGLRenderingContext) {\r\n        const mimetype = this.mimeType;\r\n        if (!MediaRecorder.isTypeSupported(mimetype)) {\r\n            console.log(\"Failed to start recording. unsupported file format\", mimetype);\r\n            return;\r\n        }\r\n\r\n        if (this.setStatusFn) {\r\n            this.setStatusFn(\"Recording\");\r\n        }\r\n\r\n        try {\r\n            const canvas = context.canvas as HTMLCanvasElement;\r\n            const chunks: Blob[] = []; // here we will store our recorded media chunks (Blobs)\r\n            const stream = canvas.captureStream(); // grab our canvas MediaStream\r\n            const rec = new MediaRecorder(stream, {\r\n                mimeType: mimetype,\r\n            }); // init the recorder\r\n\r\n            this.chunks = chunks;\r\n            this.recorder = rec;\r\n\r\n            // every time the recorder has new data, we will store it in our array\r\n            rec.ondataavailable = e => chunks.push(e.data);\r\n            // only when the recorder stops, we construct a complete Blob from all the chunks\r\n            rec.onstop = e => {\r\n                this.saveBlobFn(\r\n                    new Blob(chunks, { type: mimetype }),\r\n                    this.outputFilename\r\n                );\r\n                if (this.setStatusFn) {\r\n                    this.setStatusFn(\"Finished recording\", true);\r\n                }\r\n            }\r\n            rec.onerror = (e) => console.log(\"MediaRecorder error\", e);\r\n            rec.start();\r\n        } catch (e) {\r\n            console.log(\"Failed to start recording\", e);\r\n        }\r\n    }\r\n\r\n    public renderCallback(context: ManagedWebGLRenderingContext) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\r\nclass SaveContextDuration extends SaveContext {\r\n    public durationMs: number = 0;\r\n    public startTimeMsec: number = 0;\r\n\r\n    public setup(numSeconds: number) {\r\n        this.durationMs = numSeconds * 1000;\r\n    }\r\n\r\n    public renderCallback(context: ManagedWebGLRenderingContext) {\r\n        if (this.frameCount == 0) {\r\n            console.log(\"Start recording video\");\r\n            this.startRecording(context);\r\n            this.startTimeMsec = (new Date().getTime());\r\n        }\r\n\r\n        this.frameCount += 1\r\n        let currentTimeMsec = (new Date().getTime());\r\n        let timePassedMsec = currentTimeMsec - this.startTimeMsec;\r\n        if (timePassedMsec >= this.durationMs) {\r\n            console.log(\"Finished recording video\");\r\n            this.removalFn();\r\n            this.recorder.stop();\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\nenum SaveContextActorState {\r\n    FIRST_RENDER_CALL = 0,\r\n    WAIT_FIRST_COMPLETE = 1,\r\n    WAIT_SECOND_COMPLETE = 2,\r\n    WAIT_LAST_FRAME = 3,\r\n}\r\n\r\nclass SaveContextActor extends SaveContext {\r\n    public actor: Actor;\r\n    public state: SaveContextActorState = SaveContextActorState.FIRST_RENDER_CALL;\r\n    public animationListener: AnimationStateListener = null;\r\n\r\n    public setup(actor: Actor) {\r\n        this.actor = actor;\r\n        this.state = SaveContextActorState.FIRST_RENDER_CALL;\r\n        this.animationListener = null;\r\n    }\r\n\r\n    public renderCallback(context: ManagedWebGLRenderingContext) {\r\n        if (this.state == SaveContextActorState.FIRST_RENDER_CALL) {\r\n            this.animationListener = {\r\n                complete: (entry: TrackEntry) => {\r\n                    if (this.state == SaveContextActorState.WAIT_FIRST_COMPLETE) {\r\n                        console.log(\"start recording\");\r\n                        this.state = SaveContextActorState.WAIT_SECOND_COMPLETE;\r\n                        this.startRecording(context);\r\n                    } else if (this.state == SaveContextActorState.WAIT_SECOND_COMPLETE) {\r\n                        this.state = SaveContextActorState.WAIT_LAST_FRAME;\r\n                    }\r\n                },\r\n                event: (entry: TrackEntry, event: Event) => { },\r\n                interrupt: (entry: TrackEntry) => { },\r\n                dispose: (entry: TrackEntry) => { },\r\n                start: (entry: TrackEntry) => { },\r\n                end: (entry: TrackEntry) => { },\r\n            }\r\n            this.actor.animationState.addListener(this.animationListener);\r\n            this.frameCount += 1;\r\n            this.state = SaveContextActorState.WAIT_FIRST_COMPLETE;\r\n            return;\r\n        }\r\n\r\n        if (this.state == SaveContextActorState.WAIT_SECOND_COMPLETE) {\r\n            this.frameCount += 1;\r\n        } else if (this.state == SaveContextActorState.WAIT_LAST_FRAME) {\r\n            // Done with recording.\r\n            console.log(\"Done with recording after \", this.frameCount, \" frames\");\r\n            this.actor.animationState.removeListener(this.animationListener);\r\n            this.removalFn();\r\n            this.recorder.stop();\r\n        }\r\n    }\r\n}\r\n\r\nclass SaveContextManual extends SaveContext {\r\n    public renderCallback(context: ManagedWebGLRenderingContext) {\r\n        if (this.frameCount == 0) {\r\n            this.startRecording(context);\r\n        }\r\n        this.frameCount += 1;\r\n    }\r\n}","import \"./main.css\";\r\nimport { Runtime } from \"./stym/runtime\";\r\nimport { CanvasRecorder } from \"./stym/canvas_recorder\";\r\nimport { getRuntimeConfigFromQueryParams } from \"./stym/utils\";\r\n\r\nexport {}\r\ndeclare global {\r\n    interface Window {\r\n        SpineRuntime: Runtime;\r\n        CanvasRecorder: CanvasRecorder\r\n    }\r\n}\r\n\r\nwindow.addEventListener(\"load\", () => {\r\n    const queryString = window.location.search;\r\n    const searchParams = new URLSearchParams(queryString);\r\n    let channelName = searchParams.get('channelName');\r\n    if (!channelName || !channelName.match(/^[a-zA-Z0-9_-]+$/)) {\r\n        channelName = \"\";\r\n    }\r\n    const config = getRuntimeConfigFromQueryParams(searchParams);\r\n    window.SpineRuntime = new Runtime(channelName, config);\r\n    window.CanvasRecorder = new CanvasRecorder(\"custom_container\", window.SpineRuntime);\r\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t777: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkspine\"] = self[\"webpackChunkspine\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [43], () => (__webpack_require__(775)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","SaveContextActorState","CanvasRecorder","dom","parent","runtime","constructor","this","document","getElementById","appendChild","setupDom","id","findWithId","found","Array","findRecursive","i","children","length","child","push","findWithClass","className","classList","contains","createElement","html","innerHTML","body","setupData","addListeners","selectElem","mediaTypes","CONTAINERS","CODECS","Set","flatMap","ext","mediaType","codec","codec1","codec2","filter","variation","MediaRecorder","isTypeSupported","getAllSupportedMimeTypes","forEach","mimeType","value","crypto","randomUUID","setStatus","txt","clear","innerText","setTimeout","getOutputFilename","recordManualStart","saveContext","event","console","log","target","outputFilename","selectedMimeType","SaveContextManual","saveBlob","bind","removalFn","spinePlayer","registerRenderCallback","renderCallback","recorder","stop","addEventListener","selection","recordModeActor","recordModeDuration","recordModeManual","remove","add","querySelector","getActorNames","actorName","encodedName","encodeURIComponent","opt","encodedSelectedActor","decodedSelectedActor","decodeURIComponent","actor","getActor","undefined","SaveContextActor","setup","duration","valueAsNumber","SaveContextDuration","a","outputContainer","blob","fileName","url","window","URL","createObjectURL","href","download","click","removeChild","SaveContext","saveBlobFn","setStatusFn","chunks","frameCount","startRecording","context","mimetype","canvas","stream","captureStream","rec","ondataavailable","e","data","onstop","Blob","type","onerror","start","Error","durationMs","startTimeMsec","numSeconds","Date","getTime","state","FIRST_RENDER_CALL","animationListener","complete","entry","WAIT_FIRST_COMPLETE","WAIT_SECOND_COMPLETE","WAIT_LAST_FRAME","interrupt","dispose","end","animationState","addListener","removeListener","queryString","location","search","searchParams","URLSearchParams","channelName","get","match","config","SpineRuntime","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","key","splice","r","d","definition","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","some","chunkLoadingGlobal","self","__webpack_exports__"],"sourceRoot":""}